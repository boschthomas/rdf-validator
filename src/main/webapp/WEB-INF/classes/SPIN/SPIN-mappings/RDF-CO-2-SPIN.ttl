# namespace declarations
# ----------------------
@prefix fn:        <http://www.w3.org/2005/xpath-functions#> .
@prefix sparql:    <http://www.w3.org/TR/2013/REC-sparql11-query-20130321/#> .
@prefix xsd:       <http://www.w3.org/2001/XMLSchema#> .
@prefix rdf:       <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs:      <http://www.w3.org/2000/01/rdf-schema#> .
@prefix owl:       <http://www.w3.org/2002/07/owl#> .
@prefix sp:        <http://spinrdf.org/sp#> .
@prefix spin:      <http://spinrdf.org/spin#> .
@prefix smf:       <http://topbraid.org/sparqlmotionfunctions#> .
@prefix spif:      <http://spinrdf.org/spif#> . 
@prefix spl:       <http://spinrdf.org/spl#> .
@prefix spinowl:   <http://topbraid.org/spin/spinowl> .
@prefix spinx:     <http://spinrdf.org/spinx#> . 
@prefix functions: <http://www.example.org/functions#> .
@prefix templates: <http://www.example.org/templates#> .
@prefix sparql:    <http://www.w3.org/TR/sparql11-query/#> .
@prefix gclo2spin: <http://constraints.org/gclo2spin#> .
@prefix gclo:      <http://www.example.org/gclo#> .

# class constraints
# if a constraint has been attached to owl:Thing, it will always execute that 
# (SPINConstraints.runQueryOnClass uses SPINUtil.isRootClass which returns true for owl:Thing and rdfs:Resource)
# -----------------
owl:Thing 
	spin:constraint 
#	    [   a gclo2spin:CreateOWLThingClassAssignments ] ,
		[   a gclo2spin:minimum-qualified-cardinality-restrictions-on-properties ] ,
		[   a gclo2spin:DisjointClasses_2C ] ,
		[   a gclo2spin:existential-quantification-on-properties ] ,
		[   a gclo2spin:universal-quantification-on-properties ] .

# create OWL:Thing class assignments
# ----
gclo2spin:CreateOWLThingClassAssignments
	a spin:ConstructTemplate ;
    rdfs:subClassOf spin:ConstructTemplates ;
    # spin:violationSource
    spin:labelTemplate "create OWL:Thing class assignments" ; 
    spin:body [
        rdf:type sp:Construct ;
        sp:text """
            CONSTRUCT {
                ?type a owl:Thing .
            }
            WHERE {
	            ?instance a ?type .
			    #FILTER NOT EXISTS {
			    #    ?type rdfs:subClassOf ?anyClass .
			    #}
		    }
            """ ;
    ] .

# reasoning
# ---------
#gclo2spin:ToInfer 
#	spin:rule [
#		a sp:Construct ;
#        	sp:text """
#            	CONSTRUCT {            
#                	?this rdf:type owl:Thing .        
#            	}
#            	WHERE {            
#                	?this ?p ?o .            
#        		} """ ; ] .

# minimum qualified cardinality restrictions on properties
# --------------------------------------------------------
gclo2spin:minimum-qualified-cardinality-restrictions-on-properties
	a spin:ConstructTemplate ;
    rdfs:subClassOf spin:ConstructTemplates ;
    # spin:violationSource
    spin:labelTemplate "minimum qualified cardinality restrictions on properties" ; 
    spin:body [
        rdf:type sp:Construct ;
        sp:text """
            PREFIX gclo2spin: <http://constraints.org/gclo2spin#>
            CONSTRUCT {
                _:cv 
                	a spin:ConstraintViolation ;
                    spin:violationRoot ?subject ;
                    rdfs:label ?violationMessage ;
                    spin:violationPath ?p1 .
            }
            WHERE {	  
			    # constraint
				# ----------
				[   a gclo:PropertyConstraint ;
				    gclo:contextClass ?cc ;
				    gclo:leftProperties ( ?p1 ) ;
				    gclo:classes ( ?c1 ) ;
				    gclo:constrainingElement ">=" ;
				    gclo:constrainingValue ?cv ] .
						
				# data
				# ----
				?subject a ?cc .
				#FILTER EXISTS {
				#    ?subject ?p1 ?o1 .
				#}
				
				# validation
				# ----------
				BIND ( gclo2spin:qualifiedCardinality( ?subject, ?p1, ?c1 ) AS ?c ) .
				BIND( STRDT ( STR ( ?cv ), xsd:nonNegativeInteger ) AS ?MinimumCardinality )
				BIND( STRDT ( STR ( ?c ), xsd:nonNegativeInteger ) AS ?cardinality )
				FILTER ( ?cardinality < ?MinimumCardinality ) .	
                    
#               testing
#               -------
#                BIND ( CONCAT( 
#                    \"context concept: \", 
#                    xsd:string( ?contextClass ), 
#                    \" | cardinality: \", 
#                    xsd:string( ?cardinality ), 
#                    \" | minimum cardinality: \", 
#                    xsd:string( ?MinimumCardinality ), 
#                    \" \" ) 
#                    AS ?violationMessage ) . 

#               violation message
#               -----------------
                BIND ( CONCAT( 
                    \"minimum qualified cardinality restrictions on properties | The individual '\", 
                    xsd:string( ?subject ), 
                    \"' must be connected by '\", 
                    xsd:string( ?p1 ), 
                    \"' to at least \", 
                    xsd:string( ?MinimumCardinality ),
                    \" different individual(s) that are instances of '\", 
                    xsd:string( ?c1 ),
                    \"', but is connected to \",
                    xsd:string( ?cardinality ),
                    \" individual(s).\" ) 
                    AS ?violationMessage ) . 
            }
            """ ;
    ] .
    
# disjoint classes
# ----------------
gclo2spin:DisjointClasses_2C
	a spin:ConstructTemplate ;
    rdfs:subClassOf spin:ConstructTemplates ;
    # spin:violationSource
    spin:labelTemplate "disjoint classes" ; 
    spin:body [
        rdf:type sp:Construct ;
        sp:text """
            PREFIX gclo2spin: <http://constraints.org/gclo2spin#>
            CONSTRUCT {
                _:cv 
                	a spin:ConstraintViolation ;
                    spin:violationRoot ?subject ;
                    rdfs:label ?violationMessage .
            }
            WHERE {	  
			    # constraint
				# ----------
				?cc1
				    a gclo:ClassConstraint ;
				    gclo:contextClass ?intersection ;
				    gclo:classes ( ?c1 ?c2 ) ;
				    gclo:constrainingElement "Intersection" .
				?cc2
				    a gclo:ClassConstraint ;
				    gclo:contextClass owl:Thing ;
				    gclo:classes ( ?intersection owl:Nothing ) ;
				    gclo:constrainingElement "Inclusion" .
						
				# data
				# ----
				?subject a owl:Thing .
				
				# validation
				# ----------
				?subject a ?c1 .
				?subject a ?c2 . 

#               violation message
#               -----------------
                BIND ( CONCAT( 
                    \"Disjoint Classes | The individual '\", 
                    xsd:string( ?subject ), 
                    \"' is an instance of the disjoint classes '\", 
                    xsd:string( ?c1 ),
                    \"' and '\",
                    xsd:string( ?c2 ),
                    \"'.\"
                    ) AS ?violationMessage ) . 
            }
            """ ;
    ] .
    
# existential quantification on properties
# ----------------------------------------
gclo2spin:existential-quantification-on-properties
	a spin:ConstructTemplate ;
    rdfs:subClassOf spin:ConstructTemplates ;
    # spin:violationSource
    spin:labelTemplate "existential quantification on properties" ; 
    spin:body [
        rdf:type sp:Construct ;
        sp:text """
            PREFIX gclo2spin: <http://constraints.org/gclo2spin#>
            CONSTRUCT {
                _:cv 
                	a spin:ConstraintViolation ;
                    spin:violationRoot ?subject ;
                    rdfs:label ?violationMessage ;
                    spin:violationPath ?p1 .
            }
            WHERE {	  
			    # constraint
				# ----------
				_:pc1
				    a gclo:PropertyConstraint ;
				    gclo:contextClass ?cc ;
				    gclo:leftPropertyList ( ?p1 ) ;
				    gclo:classes ( ?c1 ) ;
				    gclo:constrainingElement "existential restrictions" .
						
				# data
				# ----
				?subject a ?cc .
				
				# validation
				# ----------
				FILTER NOT EXISTS { ?subject ?p1 ?o . ?o a ?c1 . }

#               violation message
#               -----------------
                BIND ( CONCAT( 
                    \"existential quantification on properties\"
                    ) AS ?violationMessage ) . 
            }
            """ ;
    ] .
    
# universal quantification on properties
# ----------------------------------------
gclo2spin:universal-quantification-on-properties
	a spin:ConstructTemplate ;
    rdfs:subClassOf spin:ConstructTemplates ;
    # spin:violationSource
    spin:labelTemplate "universal quantification on properties" ; 
    spin:body [
        rdf:type sp:Construct ;
        sp:text """
            PREFIX gclo2spin: <http://constraints.org/gclo2spin#>
            CONSTRUCT {
                _:cv 
                	a spin:ConstraintViolation ;
                    spin:violationRoot ?subject ;
                    rdfs:label ?violationMessage ;
                    spin:violationPath ?p1 .
            }
            WHERE {	  
			    # constraint
				# ----------
				[   a gclo:PropertyConstraint ;
				    gclo:contextClass ?cc ;
				    gclo:leftProperties ( ?p1 ) ;
				    gclo:classes ( ?c1 ) ;
				    gclo:constrainingElement "universal quantification" ] .
				[   a gclo:ClassConstraint ;
    				gclo:contextClass ?c1 ;
    				gclo:classes ( ?i1 ?i2 ?i3 ) ;
    				gclo:constrainingElement "union" ] .
						
				# data
				# ----
				?subject a ?cc .
				
				# validation
				# ----------
				?subject ?p1 ?i .
				FILTER ( ?i != ?i1 && ?i != ?i2 && ?i != ?i3 ) .

#               violation message
#               -----------------
                BIND ( CONCAT( 
                    \"universal quantification on properties\"
                    ) AS ?violationMessage ) . 
            }
            """ ;
    ] .
    
gclo2spin:qualifiedCardinality
    rdf:type spin:Function ;
    rdfs:subClassOf spin:Functions ;
    rdfs:label "qualified cardinality" ;
    rdfs:comment "qualified cardinality" ;
    spin:constraint [
        rdf:type spl:Argument ;
        spl:predicate sp:arg1 ;
        spl:valueType rdf:subject ;
        rdfs:comment "subject" ; 
    ] ;
    spin:constraint [
        rdf:type spl:Argument ;
        spl:predicate sp:arg2 ;
        spl:valueType rdf:Property ;
        rdfs:comment "property" ; 
    ] ;
    spin:constraint [
        rdf:type spl:Argument ;
        spl:predicate sp:arg3 ;
        spl:valueType rdfs:Class ;
        rdfs:comment "class" ; 
    ] ;
    spin:body [
        rdf:type sp:Select ;
        sp:text """
            SELECT ( COUNT ( ?arg1 ) AS ?cardinality)
            WHERE {
                ?arg1 ?arg2 ?o .
                ?o rdf:type ?arg3 .
            }
        """ ;
    ] ;
    spin:returnType xsd:nonNegativeInteger .