# namespace declarations
# ----------------------
@prefix fn:        <http://www.w3.org/2005/xpath-functions#> .
@prefix sparql:    <http://www.w3.org/TR/2013/REC-sparql11-query-20130321/#> .
@prefix xsd:       <http://www.w3.org/2001/XMLSchema#> .
@prefix rdf:       <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs:      <http://www.w3.org/2000/01/rdf-schema#> .
@prefix owl:       <http://www.w3.org/2002/07/owl#> .
@prefix sp:        <http://spinrdf.org/sp#> .
@prefix spin:      <http://spinrdf.org/spin#> .
@prefix smf:       <http://topbraid.org/sparqlmotionfunctions#> .
@prefix spif:      <http://spinrdf.org/spif#> . 
@prefix spl:       <http://spinrdf.org/spl#> .
@prefix spinowl:   <http://topbraid.org/spin/spinowl> .
@prefix spinx:     <http://spinrdf.org/spinx#> . 
@prefix functions: <http://www.example.org/functions#> .
@prefix templates: <http://www.example.org/templates#> .
@prefix sparql:    <http://www.w3.org/TR/sparql11-query/#> .
@prefix gclo2spin: <http://constraints.org/gclo2spin#> .
@prefix gclo:      <http://www.example.org/gclo#> .

# class constraints
# if a constraint has been attached to owl:Thing, it will always execute that 
# (SPINConstraints.runQueryOnClass uses SPINUtil.isRootClass which returns true for owl:Thing and rdfs:Resource)
# -----------------
owl:Thing 
	spin:constraint 
#	    [   a gclo2spin:CreateOWLThingClassAssignments ] ,
		[   a gclo2spin:AtLeastRestriction ] . 

# create OWL:Thing class assignments
# ----
gclo2spin:CreateOWLThingClassAssignments
	a spin:ConstructTemplate ;
    rdfs:subClassOf spin:ConstructTemplates ;
    # spin:violationSource
    spin:labelTemplate "create OWL:Thing class assignments" ; 
    spin:body [
        rdf:type sp:Construct ;
        sp:text """
            CONSTRUCT {
                ?type a owl:Thing .
            }
            WHERE {
	            ?instance a ?type .
			    #FILTER NOT EXISTS {
			    #    ?type rdfs:subClassOf ?anyClass .
			    #}
		    }
            """ ;
    ] .

# reasoning
# ---------
#gclo2spin:ToInfer 
#	spin:rule [
#		a sp:Construct ;
#        	sp:text """
#            	CONSTRUCT {            
#                	?this rdf:type owl:Thing .        
#            	}
#            	WHERE {            
#                	?this ?p ?o .            
#        		} """ ; ] .

# at-least restriction
# ---------------------
gclo2spin:AtLeastRestriction
	a spin:ConstructTemplate ;
    rdfs:subClassOf spin:ConstructTemplates ;
    # spin:violationSource
    spin:labelTemplate "at-least restrictions" ; 
    spin:body [
        rdf:type sp:Construct ;
        sp:text """
            PREFIX gclo2spin: <http://constraints.org/gclo2spin#>
            CONSTRUCT {
                _:cv 
                	a spin:ConstraintViolation ;
                    spin:violationRoot ?subject ;
                    rdfs:label ?violationMessage ;
                    spin:violationPath ?p1 .
            }
            WHERE {	  
			    # constraint
				# ----------
				?propertyConstraint
				    a gclo:PropertyConstraint ;
				    gclo:contextConcept ?contextConcept ;
				    gclo:leftPropertyList ( ?p1 ) ;
				    gclo:concepts ( ?c1 ) ;
				    gclo:constrainingElement ?constrainingElement ;
				    gclo:constrainingValue ?constrainingValue .
						
				# data
				# ----
				?subject a ?contextConcept .
				FILTER EXISTS {
				    ?subject ?p1 ?o1 .
				}
				
				# validation
				# ----------
				FILTER ( ?constrainingElement = ">=" ) .
				BIND ( gclo2spin:qualifiedCardinality( ?subject, ?p1, ?c1 ) AS ?c ) .
				BIND( STRDT ( STR ( ?constrainingValue ), xsd:nonNegativeInteger ) AS ?MinimumCardinality )
				BIND( STRDT ( STR ( ?c ), xsd:nonNegativeInteger ) AS ?cardinality )
				FILTER ( ?cardinality < ?MinimumCardinality ) .	
                    
#               testing
#               -------
#                BIND ( CONCAT( 
#                    \"context concept: \", 
#                    xsd:string( ?contextConcept ), 
#                    \" | cardinality: \", 
#                    xsd:string( ?cardinality ), 
#                    \" | minimum cardinality: \", 
#                    xsd:string( ?MinimumCardinality ), 
#                    \" \" ) 
#                    AS ?violationMessage ) . 

#               violation message
#               -----
                BIND ( CONCAT( 
                    \"at-least restriction | The individual '\", 
                    xsd:string( ?subject ), 
                    \"' can only be connected by '\", 
                    xsd:string( ?p1 ), 
                    \"' to at least \", 
                    xsd:string( ?MinimumCardinality ),
                    \" different individual(s) that are instances of '\", 
                    xsd:string( ?c1 ),
                    \"', but is connected to \",
                    xsd:string( ?cardinality ),
                    \" individual(s).\" ) 
                    AS ?violationMessage ) . 
            }
            """ ;
    ] .
    
gclo2spin:qualifiedCardinality
    rdf:type spin:Function ;
    rdfs:subClassOf spin:Functions ;
    rdfs:label "qualified cardinality" ;
    rdfs:comment "qualified cardinality" ;
    spin:constraint [
        rdf:type spl:Argument ;
        spl:predicate sp:arg1 ;
        spl:valueType rdf:subject ;
        rdfs:comment "subject" ; 
    ] ;
    spin:constraint [
        rdf:type spl:Argument ;
        spl:predicate sp:arg2 ;
        spl:valueType rdf:Property ;
        rdfs:comment "property" ; 
    ] ;
    spin:constraint [
        rdf:type spl:Argument ;
        spl:predicate sp:arg3 ;
        spl:valueType rdfs:Class ;
        rdfs:comment "class" ; 
    ] ;
    spin:body [
        rdf:type sp:Select ;
        sp:text """
            SELECT ( COUNT ( ?arg1 ) AS ?cardinality)
            WHERE {
                ?arg1 ?arg2 ?o .
                ?o rdf:type ?arg3 .
            }
        """ ;
    ] ;
    spin:returnType xsd:nonNegativeInteger .